{
  parserClass="com.github.alxmag.intellijfakersupport.lang.FakerParser"
  parserUtilClass="com.github.alxmag.intellijfakersupport.lang.FakerParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Faker"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.alxmag.intellijfakersupport.lang.psi"
  psiImplPackage="com.github.alxmag.intellijfakersupport.lang.psi.impl"

  elementTypeHolderClass="com.github.alxmag.intellijfakersupport.lang.psi.FakerTypes"
  elementTypeClass="com.github.alxmag.intellijfakersupport.lang.psi.FakerElementType"
  tokenTypeClass="com.github.alxmag.intellijfakersupport.lang.psi.FakerTokenType"

  tokens = [
    REGULAR_STRING_PART="regexp:(([^\\\"\#]) | (#[^{]))"
    EXPRESSION_LBRACE='#{'
    EXPRESSION_RBRACE='}'

    // PARAM_BEGIN = "'"
    // PARAM_END = "'"

    DOT='.'
    COMMA=','

    PARAMS_LIST_BEGIN="regexp:(\s)+"

    IDENTIFIER="regexp:[a-zA-Z]+[a-zA-Z0-9]+"
  ]

  extends("paramLiteral|paramExpression")=paramStatement
}

fakerFile ::= template_part_*
private template_part_ ::= (REGULAR_STRING_PART|expression)
expression ::= EXPRESSION_LBRACE functionName paramsListDeclaration? EXPRESSION_RBRACE {
  pin=1
}
functionName ::= IDENTIFIER (DOT IDENTIFIER)*

private paramsListDeclaration ::= PARAMS_LIST_BEGIN expressionParamsList {
  pin=1
}
expressionParamsList ::= paramDeclaration*

private paramDeclaration ::= param (','|&'}') {
  pin=1
  recoverWhile=not_rbrace_or_next_param_declaration
}
param ::= PARAM_BEGIN paramStatement PARAM_END {
  pin=1
}
paramStatement ::= paramExpression | paramLiteral
paramLiteral ::= REGULAR_STRING_PART?
paramExpression ::= EXPRESSION_LBRACE functionName EXPRESSION_RBRACE {
  pin=1
}

private not_rbrace_or_next_param_declaration ::= !('}'|paramDeclaration)