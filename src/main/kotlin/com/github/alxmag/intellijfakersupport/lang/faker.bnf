{
  parserClass="com.github.alxmag.intellijfakersupport.lang.FakerParser"
  parserUtilClass="com.github.alxmag.intellijfakersupport.lang.FakerParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Faker"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.alxmag.intellijfakersupport.lang.psi"
  psiImplPackage="com.github.alxmag.intellijfakersupport.lang.psi.impl"

  psiImplUtilClass="com.github.alxmag.intellijfakersupport.lang.psi.impl.FakerPsiImplUtil"

  elementTypeHolderClass="com.github.alxmag.intellijfakersupport.lang.psi.FakerTypes"
  elementTypeClass="com.github.alxmag.intellijfakersupport.lang.psi.FakerElementType"
  tokenTypeClass="com.github.alxmag.intellijfakersupport.lang.psi.FakerTokenType"

  tokens = [
    REGULAR_STRING_PART="regexp:(([^\\\"\#]) | (#[^{]))"
    EXPRESSION_LBRACE='#{'
    EXPRESSION_RBRACE='}'

    // PARAM_BEGIN = "'"
    // PARAM_END = "'"

    DOT='.'
    COMMA=','

    PARAMS_LIST_BEGIN="regexp:(\s)+"

    IDENTIFIER="regexp:[a-zA-Z]+[a-zA-Z0-9]+"
  ]

//  extends("l2Expression|literal")=l1ParamValue
//  extends("l3Expression|literal")=l2ParamValue
//  extends("|")
}

fakerFile ::= l1Template

///// L1 /////
private l1Template ::= (l1Expression | content)*
l1Expression ::= EXPRESSION_LBRACE functionName l1ParamsListDeclaration? EXPRESSION_RBRACE {
  pin=1
  name="Expression"
}
functionName ::= IDENTIFIER (DOT IDENTIFIER)* {
  methods=[getFunctionName]
}
private l1ParamsListDeclaration ::= PARAMS_LIST_BEGIN l1ExpressionParamsList {
  pin=1
}
private l1ExpressionParamsList ::= l1ParamDeclaration*
private l1ParamDeclaration ::= l1Param (','|&'}') {
  pin=1
  recoverWhile=not_rbrace_or_next_l1ParamDeclaration
}
l1Param ::= PARAM_BEGIN l2Template PARAM_END {
  pin=1
  name="Single-quoted parameter"
}

///// L2 /////
private l2Template ::= (l2Expression | content)*
l2Expression ::= EXPRESSION_LBRACE functionName l2ExpressionParamsList? EXPRESSION_RBRACE {
  pin=1
  name="Nested expression"
}
private l2ExpressionParamsList ::= PARAMS_LIST_BEGIN l2ParamsList {
  pin=1
}
l2ParamsList ::= l2ParamDeclaration*
private l2ParamDeclaration ::= l2Param (','|&'}') {
  pin=1
  recoverWhile=not_rbrace_or_next_l2ParamDeclaration
}
// #{top #{nested ''<thisParam>''}}
l2Param ::= PARAM_DOUBLE_QUOTE_BEGIN l3Template PARAM_DOUBLE_QUOTE_END {
  pin=1
  name="Double apostrophe parameter"
}

///// L3 /////
private l3Template ::= (l3Expression | content)*
// L3 Expression has no params
l3Expression ::= EXPRESSION_LBRACE functionName EXPRESSION_RBRACE {
  pin=1
  name="Nested expression"
}

///// Common /////
content ::= REGULAR_STRING_PART

private not_rbrace_or_next_l1ParamDeclaration ::= !('}'|l1ParamDeclaration)
private not_rbrace_or_next_l2ParamDeclaration ::= !('}'|l2ParamDeclaration)